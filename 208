1.JDK和JRE有什么区别
  JDK,java develop kit java开发工具包，包括运行环境和开发环境（各种工具，javac之类的）
  JRE，java runtime environment，java运行环境，一些基本类库和虚拟机
  JDK>JRE>虚拟机
2.==和equals的区别是什么
  ==如果是基本数据类型，比较值是否一致，如果是对象，比较内存地址是否相同
  equals默认和==一致，只是有的类修改了，比如string，比较指向的内容是否一致
3.两个对象的hashcode相同，equals也一定一致吗
  不一定，hashcode如何计算（https://blog.csdn.net/qq_38182963/article/details/78940047）
  String 的hashCode计算
  public int hashCode(){
    int h=hash;
    if(h == 0 && value.lenght > 0){
      char val[] = value;
      for(int i=0;i<value.length;i++){
        h=31*h+val[i];
      }
      hash=h;
    }
    return h;
   }
  .为什么使用31
    31*i=(i<<5)-i;
4.final 在java中有什么用
  final 类 不可被继承改写
  final 方法 不可被改写
  final 值 不可被修改
5.Math.round(-1.5)
  -1
6.String不属于基本数据类型
7.java中操作字符串的类有哪些
  string 不可变，char[] value被final修饰
  stringbuilder  可变，线程不安全
  stringbuffer    可变，线程安全 方法被synchronized修饰
8 String str="i"和String str=new String("i")有区别吗
  有，"i"是字面量，在方法区，第一个直接指向方法区字面量，第二个指向堆内地址
9.如何将字符串反转
  string 没有reverse方法，stringbuffer和stringbuilder可以
10.String类常用的方法有哪些
   charAt trim equals replace machtches split substring
11.抽象类必须有抽象方法吗
   可以没有，甚至可以有Main方法
12.普通类和抽象类有什么区别
   abstract关键字
   普通类不能有抽象方法
   抽象类不能实例化
13.抽象类能用final修饰吗
  不可以
14.接口和抽象类有什么区别
  关键字
  接口里的变量都是final类型，不能用private，抽象类可以有普通变量
  接口里不能有非抽象方法，抽象类可以有（接口可以使用default方法）
  接口多实现，抽象类单继承
15.java中的io流
  输入流输出流
  字符流（16位）字节流（8位）
16.Bio，Nio，Aio区别（https://zhuanlan.zhihu.com/p/66148226）
  Bio ，Block io，同步阻塞，无论是等待建立连接或是传输数据，都会阻塞，程序不能像下执行
  Nio ，New io ，同步非阻塞，主要组件：选择器，通道，缓冲
  
17.锁升级
   对象放在内存中，分为对象头，实例变量，填充字节
    对象头有mark word，class point（指向它的类元数据的指针）
    实例变量存储的是属性信息，包括父类的属性信息，按照四字节对其
    填充字符，要求8字节的整数倍
    在64位的虚拟机中，mark word https://img-blog.csdn.net/20180322153316377
    
    锁状态                       56bit                           1bit                  4bit              1bit                    2bit
                        25bit                 31bit                                                 是否偏向锁                 锁标志位
    无锁                unused                hashcode           cms_free             对象分代年龄        0                       01
    偏向锁              锁偏向的线程threadID(54bit)  epoch（2bit） cms_free             对象分代年龄        1                       01
    轻量级锁                                      指向栈中锁记录的指针                                                              00
    重量级锁                                      指向重量级锁的指针                                                                10
    GC标记                                          空                                                                            11
    
    Synchronized对应的是重量级锁
      重量级锁对应的锁标志位是10，存储了指向重量级监视器锁的指针，在hospot中，对象的监视器（monitor）锁对象由ObjectMonitor对象实现（C++）
      数据结构：
        ObjectMonitor（）{
          _count      =0;   //用来记录该对象被线程获取锁的次数
          _waiters    =0;  
          _recursions =0;   //锁的重入次数
          _owner      =null;//指向持有ObjectMonitor对象的线程
          _WaitSet    =null;//处于wait状态的线程，会被加入到_waitSet
          _waitSetLock=0;   
          _EntryList  =null;//处于等待锁block状态的线程，会被加入该列表
        }
      偏向锁：
        大多数时候是不存在竞争的情况下，常常是一个线程多次获得同一个锁，因此如果每次都要竞争会增大很多没有必要付出的代价，为了降低获取锁的代价，才引入偏向锁
        当线程1访问代码块并获取锁对象时，会在java对象头和栈帧中记录偏向的锁的threadID,因为偏向锁不会主动释放锁，因此以后线程1再次获取锁的时候，需要比较当前线程
        的threadID和java对象头中ttreadID是否一致，如果一致，还是线程1获取锁对象，无需使用CAS加锁，如果不一致，比如线程2请求，那么查看java对象头中记录的线程1
        是否存活，若没有存货，那么锁对象被重置为无锁状态，其他线程2可以将其置成偏向锁，如果存活，立刻查找这个线程的栈帧，如果还需要继续使用这个线程，那么暂停1，撤销偏向锁，升级为轻量级锁，如果线程1
        不需要使用该锁，将锁对象设为无锁，重新偏向新的线程
     轻量级锁：
        考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。自旋等待
        线程1获取轻量级锁时先把锁对象的对象头Markword复制一份到自己的栈帧中用于存储所记录空间，然后使用cas把对象头中的内容替换为线程1存储的锁记录的地址
        如果在线程1复制对象头的同时（在线程cas之前），线程2也准备获取锁，复制了对象头的线程2的锁记录空间中，但是在线程2CAS的时候，发现线程1已经把对象头换了，线程2的
        cas失败，那么线程2就尝试使用自旋锁来等待1释放锁
        自选一定次数之后升级为重量级锁，把除了拥有锁的线程都阻塞，防止cpu空转
     注意：为了避免无用的自旋，轻量级锁一旦膨胀为重量级锁就不会再降级为轻量级锁了；偏向锁升级为轻量级锁也不能再降级为偏向锁。但是偏向锁可以被重置为无锁
     所以适用范围显而易见：
        偏向锁：基本是单线程
        轻量级锁：多线程，切换频繁
        重量级锁：多线程，占有时间长
     
49 什么是死锁
  多个线程竞争资源，陷入循环等待，如果没有一个线程放弃请求，永远不能向前进行
50怎么防止死锁
  死锁的四个条件：互斥，非抢占，占有并等待，循环等待，破坏条件：
  一次申请所有的资源，申请不到即放弃，给资源编号
51.ThreadLocal https://blog.csdn.net/X8i0Bev/article/details/101086604
  ThreadLocal是一个本地线程副本变量工具类，各个线程都拥有一份线程私有的数据，线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用。
  实现：每个thread内部有一个map，key是共享变量的名字，value是真正的变量副本
  threadLocat的set
  public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    }
    public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }
    应用场景：数据库连接，session
   52.synchronized实现原理
    普通方法，静态方法，同步代码块
    重新中内存中取值，并锁定不能被修改，通过修改对象头，每个对象头有个monitor，monitor锁指针指向该该线程
   53.synchronized和volatile的区别
    volatile虽然保证了可见性，但是没有锁机制，同时能有多个线程访问到原始数据，然后一起修改更新回主存，因为并发性高，所以性能高
    volatile只能修饰变量
    volatie不能被优化
  54.synchronized和lock有甚区别
    实现交替打印（1.synchronized和wait notify 2.lock condition 3.lockpart）
    看一下Lock实现ReentrantLock
   final void lock() {
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
   }
        
    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
    tryAcquire调用以下
    final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0) // overflow
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
   acquireQueued（） 调用以下
   final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
    addWaiter如以下：
    private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        enq(node);
        return node;
    }
    
    二者区别：
      用法
      一个队列和两个队列
      一个是对对象头，监视器的操作，一个是对线程的操作
54 synchronized和lock的区别
    synchronized是个关键字，jvm层面，lock是个java类
    synchronized无法判断是否获取锁的状态，lock可以判断
    synchronized会自动释放锁
    synchronized可重入，不可中断，非公平
55 synchronized和ReetrantLock区别
  对获取锁的时间进行设置，避免一直阻塞
  synchronized通过对象头实现，reentrantlock通过unsafe.park实现，unsafe实现
    
55.说一下atomic的原理
  我举得先看下unsafe类：
    unsafe功能：
      普通读写：读写一个object对象的field，直接从内存的一个地址读写
      volatile读写：volatile读写一个object的field，volatile可以保证可见性和有序性
      有序写：有序写一个object的field，保证有序性，不保证可见性
      内存操作：申请内存，重新申请内存，释放内存，内存复制
      cas相关：提供int，long，object的cas操作
      偏移量相关：获取对象属性和静态属性的偏移量
      线程调度：挂起线程，唤醒线程
      类加载：定义类，创建对象，定义匿名内粗堡垒，判断是否加载类
      内存屏障：读屏障，写屏障，读写屏障
      
      LockSupport基于unsafe实现
      Atomic 值volatile ，所有的操作都通过unsafe
56.什么是反射
  反射是可以在运行时对类进行操作，可以在运行时拿到类的信息，拿到类的方法，字段，开可以newInstance生
57 什么是序列化，什么情况下需要序列化
  把java对象的状态保存下来，字节流的形式，并可以从字节流中读取恢复java对象
  网络数据传输，数据存储，远程接口调用
58.动态代理是什么，有哪些应用
   代理有动态代理和静态代理，静态代理类一般是在运行前生成
   动态代理类可以在运行时生成
   动态代理用于aop，事务，日志，权限这些
59.怎么实现动态代理
  java api：
    被代理的类要实现一个接口，自己实现一个vocationHandler，里面实现逻辑，然后以Proxy.newSincetance()生成代理对象，直接执行
  cglb：
    Enhancer 可以设置superClass，设置MethodInterceptor，里面实现逻辑，不能增强final 方法
60.为什么用使用克隆
    有些对象初始化比较复杂，新建的对象和上一个只有很小的不同，clone是一个native方法，效率很高
61.如何实现对象克隆
    实现重写clone方法，clone里对每个属性进行克隆，要注意到object 有protected clone方法，也就是说，看起来好像可以不implements Cloneable接口，但是如果没有
    implements Cloneable 直接调用clone会报CloneNotSupportedException
    也可以通过序列化实现克隆
62.深拷贝和浅拷贝
  对于值来说：都一样
  对于对象：深拷贝指向另一个地址，浅拷贝指向同一个地址
63.jsp和servlet有什么区别
  tomcat处理请求都是通过servlet来处理，jsp编译之后也是servlet
  
66.jsp的四种作用域
  page（一个页面相关的对象和属性）
  request（一个请求可能跨越多个页面，涉及多个web组件）
  session
  application 服务器全局属性
67.session和cookie有什么区别
  现在实现的session和cookie都属于session，都是为了记录会话的状态
  cookie保存在客户端
  session保存在服务器端
  cookie保存session
68 session的工作原理：
  服务端调用getSession创建，类似于key-value的形式，把sessionId也就是key返回给客户端，客户端请求的时候拿着sessionId，服务端就能根据id找到相关信息
  ，一般通过cookie传递或者通过url参数
69.如果客户端禁止cookie，session还能用吗
  只要能传递参数给服务端就可以，最简单的就是通过url传参
70.spring mvc和struts的区别是什么
  Struts2是类级别的拦截，每个地址都对应一个action类，请求数据是通过set注入的，参数注入类中，每个接口都要配置，性能应该是比较低的
  SpringMvc 是通过在DispatcherServlet中的doDispatch进行拦截的，每个controller方法方法对应自己的Request和response，参数直接注入方法，Controller默认
  作用域是单例，默认对所有的请求，创建一个Controller
  拦截机制：Strut2用自己的拦截机制，springMvc是aop方式，配置少
  底层：Strtus的实现是基于个Filter，SpringMvc基于Servlet，
  
 
 
一个重点：Servlet，Filter，Listener，Interceptor
  其中Servlet，Filter，Listener是java servlet官方的，Interceptor是一些mvc框架自定义的
  Servlet就是接受请求，计算，做出返回
  Listener 更像是对一些关键事件进行监听，比如spring用到的contextLoadListener，HttpSessionListener
  Filter 是对HttpRequest和response进行截取，然后做处理
SpringMVC处理流程：
  因为在web.xml中配置了DispatcherServlet，还有/，对于它拦截到的请求
  无论是doGet，还是doPost，或者是doPut，doDelte这些都是调用processRequest处理
  processRequest前后是一些对属性的封装之类，发布监听事件之类，核心在doService中
  doService的前面是一些属性的设置，比如几个重要的resolver，核心是doDispatch
  几个核心的HandlerExecutionChain（核心，包括钩子和业务方法），HandlerMapping（负责url映射），HandlerAdater主要是反射执行（最终是handleRequestInternal-》invoka）
  对于modelandview，如果只有数据，view为空，如果有view找到viewResolver，这个会找到并渲染
      protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
        HttpServletRequest processedRequest = request;
        HandlerExecutionChain mappedHandler = null;
        boolean multipartRequestParsed = false;
        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

        try {
            try {
                ModelAndView mv = null;
                Object dispatchException = null;

                try {
                    processedRequest = this.checkMultipart(request);
                    multipartRequestParsed = processedRequest != request;
                    //根据request的url获取对应的HandlerExecutionChain（Interchain），和方法
                    mappedHandler = this.getHandler(processedRequest);
                    if (mappedHandler == null) {
                        this.noHandlerFound(processedRequest, response);
                        return;
                    }
                    //然后得到HandlerAdapter
                    HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler());
                    String method = request.getMethod();
                    boolean isGet = "GET".equals(method);
                    if (isGet || "HEAD".equals(method)) {
                        long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                        if ((new ServletWebRequest(request, response)).checkNotModified(lastModified) && isGet) {
                            return;
                        }
                    }
                    //拦截器前面的逻辑
                    if (!mappedHandler.applyPreHandle(processedRequest, response)) {
                        return;
                    }
                    //handlerAdapter 用反射执行
                    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
                    if (asyncManager.isConcurrentHandlingStarted()) {
                        return;
                    }

                    this.applyDefaultViewName(processedRequest, mv);
                    //拦截器
                    mappedHandler.applyPostHandle(processedRequest, response, mv);
                } catch (Exception var20) {
                    dispatchException = var20;
                } catch (Throwable var21) {
                    dispatchException = new NestedServletException("Handler dispatch failed", var21);
                }

                this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);
            } catch (Exception var22) {
                this.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);
            } catch (Throwable var23) {
                this.triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException("Handler processing failed", var23));
            }

        } finally {
            if (asyncManager.isConcurrentHandlingStarted()) {
                if (mappedHandler != null) {
                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
                }
            } else if (multipartRequestParsed) {
                this.cleanupMultipart(processedRequest);
            }

        }
    }

71.如何避免sql注入
  使用PreparedStatement预编译
72.throw和throws区别
  throws在方法上抛出，往上传，不处理
  throw代码里抛出
73.final,finally,finalize 区别
  final 类，方法，变量
  finally try catch finally必须执行
  finalize 要被gc的时候会执行的方法
74.try,catch,finally中，如果catch中return了，finall是否会执行
  public static int a(){
        int a=10;
        try{
            a=20;
            a=10/0;
            return a;
        }catch (Exception e){
            return a;
        }finally {
            a=30;
            
        }
    }
    返回试一下上面这个方法，联想一下函数执行过程操作数栈，出口地址相关，其实就是在return的时候把操作数的值赋给某个地址，然后继续向下执行
 78.常见的异常类有哪些
    throwable->error
    throwable->exception
    java中只有throwable类型才可以被throw和catch
    exception通常是可以预料到的，没有error严重，catch到就可以继续执行，又分为检查异常和非检查异常（RuntimeException）,检查异常必须在写代码的时候trycatch，
    比如ioexception，非检查异常可以不catch
    error通常是问题比较严重，jvm级别的，outofmemory这些，一般出现就差不多gg了
 79.http响应码301和302区别，以及重定向和forward的区别，浏览器是怎么处理的
    301永久重定向 浏览器缓冲新地址，以后直接请求新地址
    302临时重定向q 浏览器每次先收到302，再请求新地址，response.sendRedirect();
 80.forward和redirect的区别
    地址栏没有变化
    带着同样的参数就过去了，redirect传参比较麻烦
 81.简述TCP和UDP的区别：
  
