1.JDK和JRE有什么区别
  JDK,java develop kit java开发工具包，包括运行环境和开发环境（各种工具，javac之类的）
  JRE，java runtime environment，java运行环境，一些基本类库和虚拟机
  JDK>JRE>虚拟机
2.==和equals的区别是什么
  ==如果是基本数据类型，比较值是否一致，如果是对象，比较内存地址是否相同
  equals默认和==一致，只是有的类修改了，比如string，比较指向的内容是否一致
3.两个对象的hashcode相同，equals也一定一致吗
  不一定，hashcode如何计算（https://blog.csdn.net/qq_38182963/article/details/78940047）
  String 的hashCode计算
  public int hashCode(){
    int h=hash;
    if(h == 0 && value.lenght > 0){
      char val[] = value;
      for(int i=0;i<value.length;i++){
        h=31*h+val[i];
      }
      hash=h;
    }
    return h;
   }
  .为什么使用31
    31*i=(i<<5)-i;
4.final 在java中有什么用
  final 类 不可被继承改写
  final 方法 不可被改写
  final 值 不可被修改
5.Math.round(-1.5)
  -1
6.String不属于基本数据类型
7.java中操作字符串的类有哪些
  string 不可变，char[] value被final修饰
  stringbuilder  可变，线程不安全
  stringbuffer    可变，线程安全 方法被synchronized修饰
8 String str="i"和String str=new String("i")有区别吗
  有，"i"是字面量，在方法区，第一个直接指向方法区字面量，第二个指向堆内地址
9.如何将字符串反转
  string 没有reverse方法，stringbuffer和stringbuilder可以
10.String类常用的方法有哪些
   charAt trim equals replace machtches split substring
11.抽象类必须有抽象方法吗
   可以没有，甚至可以有Main方法
12.普通类和抽象类有什么区别
   abstract关键字
   普通类不能有抽象方法
   抽象类不能实例化
13.抽象类能用final修饰吗
  不可以
14.接口和抽象类有什么区别
  关键字
  接口里的变量都是final类型，不能用private，抽象类可以有普通变量
  接口里不能有非抽象方法，抽象类可以有（接口可以使用default方法）
  接口多实现，抽象类单继承
15.java中的io流
  输入流输出流
  字符流（16位）字节流（8位）
16.Bio，Nio，Aio区别（https://zhuanlan.zhihu.com/p/66148226）
  Bio ，Block io，同步阻塞，无论是等待建立连接或是传输数据，都会阻塞，程序不能像下执行
  Nio ，New io ，同步非阻塞，主要组件：选择器，通道，缓冲
  
17.锁升级
   对象放在内存中，分为对象头，实例变量，填充字节
    对象头有mark word，class point（指向它的类元数据的指针）
    实例变量存储的是属性信息，包括父类的属性信息，按照四字节对其
    填充字符，要求8字节的整数倍
    在64位的虚拟机中，mark word https://img-blog.csdn.net/20180322153316377
    
    锁状态                       56bit                           1bit                  4bit              1bit                    2bit
                        25bit                 31bit                                                 是否偏向锁                 锁标志位
    无锁                unused                hashcode           cms_free             对象分代年龄        0                       01
    偏向锁              锁偏向的线程threadID(54bit)  epoch（2bit） cms_free             对象分代年龄        1                       01
    轻量级锁                                      指向栈中锁记录的指针                                                              00
    重量级锁                                      指向重量级锁的指针                                                                10
    GC标记                                          空                                                                            11
    
    Synchronized对应的是重量级锁
      重量级锁对应的锁标志位是10，存储了指向重量级监视器锁的指针，在hospot中，对象的监视器（monitor）锁对象由ObjectMonitor对象实现（C++）
      数据结构：
        ObjectMonitor（）{
          _count      =0;   //用来记录该对象被线程获取锁的次数
          _waiters    =0;  
          _recursions =0;   //锁的重入次数
          _owner      =null;//指向持有ObjectMonitor对象的线程
          _WaitSet    =null;//处于wait状态的线程，会被加入到_waitSet
          _waitSetLock=0;   
          _EntryList  =null;//处于等待锁block状态的线程，会被加入该列表
        }
      偏向锁：
        大多数时候是不存在竞争的情况下，常常是一个线程多次获得同一个锁，因此如果每次都要竞争会增大很多没有必要付出的代价，为了降低获取锁的代价，才引入偏向锁
        当线程1访问代码块并获取锁对象时，会在java对象头和栈帧中记录偏向的锁的threadID,因为偏向锁不会主动释放锁，因此以后线程1再次获取锁的时候，需要比较当前线程
        的threadID和java对象头中ttreadID是否一致，如果一致，还是线程1获取锁对象，无需使用CAS加锁，如果不一致，比如线程2请求，那么查看java对象头中记录的线程1
        是否存活，若没有存货，那么锁对象被重置为无锁状态，其他线程2可以将其置成偏向锁，如果存活，立刻查找这个线程的栈帧，如果还需要继续使用这个线程，那么暂停1，撤销偏向锁，升级为轻量级锁，如果线程1
        不需要使用该锁，将锁对象设为无锁，重新偏向新的线程
     轻量级锁：
        考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。自旋等待
        线程1获取轻量级锁时先把锁对象的对象头Markword复制一份到自己的栈帧中用于存储所记录空间，然后使用cas把对象头中的内容替换为线程1存储的锁记录的地址
        如果在线程1复制对象头的同时（在线程cas之前），线程2也准备获取锁，复制了对象头的线程2的锁记录空间中，但是在线程2CAS的时候，发现线程1已经把对象头换了，线程2的
        cas失败，那么线程2就尝试使用自旋锁来等待1释放锁
        自选一定次数之后升级为重量级锁，把除了拥有锁的线程都阻塞，防止cpu空转
     注意：为了避免无用的自旋，轻量级锁一旦膨胀为重量级锁就不会再降级为轻量级锁了；偏向锁升级为轻量级锁也不能再降级为偏向锁。但是偏向锁可以被重置为无锁
     所以适用范围显而易见：
        偏向锁：基本是单线程
        轻量级锁：多线程，切换频繁
        重量级锁：多线程，占有时间长
     
49 什么是死锁
  多个线程竞争资源，陷入循环等待，如果没有一个线程放弃请求，永远不能向前进行
50怎么防止死锁
  死锁的四个条件：互斥，非抢占，占有并等待，循环等待，破坏条件：
  一次申请所有的资源，申请不到即放弃，给资源编号
51.ThreadLocal https://blog.csdn.net/X8i0Bev/article/details/101086604
  ThreadLocal是一个本地线程副本变量工具类，各个线程都拥有一份线程私有的数据，线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用。
  实现：每个thread内部有一个map，key是共享变量的名字，value是真正的变量副本
  threadLocat的set
  public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    }
    public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }
    应用场景：数据库连接，session
   52.synchronized实现原理
    普通方法，静态方法，同步代码块
    重新中内存中取值，并锁定不能被修改，通过修改对象头，每个对象头有个monitor，monitor锁指针指向该该线程
   53.synchronized和volatile的区别
    volatile虽然保证了可见性，但是没有锁机制，同时能有多个线程访问到原始数据，然后一起修改更新回主存，因为并发性高，所以性能高
    volatile只能修饰变量
    volatie不能被优化
  54.synchronized和lock有甚区别
    实现交替打印（1.synchronized和wait notify 2.lock condition 3.lockpart）
    看一下Lock实现ReentrantLock
   final void lock() {
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
   }
        
    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
    tryAcquire调用以下
    final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0) // overflow
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
   acquireQueued（） 调用以下
   final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
    addWaiter如以下：
    private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        enq(node);
        return node;
    }
    
    二者区别：
      用法
      一个队列和两个队列
      一个是对对象头，监视器的操作，一个是对线程的操作
54 synchronized和lock的区别
    synchronized是个关键字，jvm层面，lock是个java类
    synchronized无法判断是否获取锁的状态，lock可以判断
    synchronized会自动释放锁
    synchronized可重入，不可中断，非公平
55 synchronized和ReetrantLock区别
  对获取锁的时间进行设置，避免一直阻塞
  synchronized通过对象头实现，reentrantlock通过unsafe.park实现，unsafe实现
    
55.说一下atomic的原理
  我举得先看下unsafe类：
    unsafe功能：
      普通读写：读写一个object对象的field，直接从内存的一个地址读写
      volatile读写：volatile读写一个object的field，volatile可以保证可见性和有序性
      有序写：有序写一个object的field，保证有序性，不保证可见性
      内存操作：申请内存，重新申请内存，释放内存，内存复制
      cas相关：提供int，long，object的cas操作
      偏移量相关：获取对象属性和静态属性的偏移量
      线程调度：挂起线程，唤醒线程
      类加载：定义类，创建对象，定义匿名内粗堡垒，判断是否加载类
      内存屏障：读屏障，写屏障，读写屏障
      
      LockSupport基于unsafe实现
      Atomic 值volatile ，所有的操作都通过unsafe
56.什么是反射
  反射是可以在运行时对类进行操作，可以在运行时拿到类的信息，拿到类的方法，字段，开可以newInstance生
57 什么是序列化，什么情况下需要序列化
  把java对象的状态保存下来，字节流的形式，并可以从字节流中读取恢复java对象
  网络数据传输，数据存储，远程接口调用
58.动态代理是什么，有哪些应用
   代理有动态代理和静态代理，静态代理类一般是在运行前生成
   动态代理类可以在运行时生成
   动态代理用于aop，事务，日志，权限这些
59.怎么实现动态代理
  java api：
    被代理的类要实现一个接口，自己实现一个vocationHandler，里面实现逻辑，然后以Proxy.newSincetance()生成代理对象，直接执行
  cglb：
    Enhancer 可以设置superClass，设置MethodInterceptor，里面实现逻辑，不能增强final 方法
60.为什么用使用克隆
    有些对象初始化比较复杂，新建的对象和上一个只有很小的不同，clone是一个native方法，效率很高
61.如何实现对象克隆
    实现重写clone方法，clone里对每个属性进行克隆，要注意到object 有protected clone方法，也就是说，看起来好像可以不implements Cloneable接口，但是如果没有
    implements Cloneable 直接调用clone会报CloneNotSupportedException
    也可以通过序列化实现克隆
62.深拷贝和浅拷贝
  对于值来说：都一样
  对于对象：深拷贝指向另一个地址，浅拷贝指向同一个地址
63.jsp和servlet有什么区别
  tomcat处理请求都是通过servlet来处理，jsp编译之后也是servlet
  
66.jsp的四种作用域
  page（一个页面相关的对象和属性）
  request（一个请求可能跨越多个页面，涉及多个web组件）
  session
  application 服务器全局属性
67.session和cookie有什么区别
  现在实现的session和cookie都属于session，都是为了记录会话的状态
  cookie保存在客户端
  session保存在服务器端
  cookie保存session
68 session的工作原理：
  服务端调用getSession创建，类似于key-value的形式，把sessionId也就是key返回给客户端，客户端请求的时候拿着sessionId，服务端就能根据id找到相关信息
  ，一般通过cookie传递或者通过url参数
69.如果客户端禁止cookie，session还能用吗
  只要能传递参数给服务端就可以，最简单的就是通过url传参
70.spring mvc和struts的区别是什么
  Struts2是类级别的拦截，每个地址都对应一个action类，请求数据是通过set注入的，参数注入类中，每个接口都要配置，性能应该是比较低的
  SpringMvc 是通过在DispatcherServlet中的doDispatch进行拦截的，每个controller方法方法对应自己的Request和response，参数直接注入方法，Controller默认
  作用域是单例，默认对所有的请求，创建一个Controller
  拦截机制：Strut2用自己的拦截机制，springMvc是aop方式，配置少
  底层：Strtus的实现是基于个Filter，SpringMvc基于Servlet，
  
 
 
一个重点：Servlet，Filter，Listener，Interceptor
  其中Servlet，Filter，Listener是java servlet官方的，Interceptor是一些mvc框架自定义的
  Servlet就是接受请求，计算，做出返回
  Listener 更像是对一些关键事件进行监听，比如spring用到的contextLoadListener，HttpSessionListener
  Filter 是对HttpRequest和response进行截取，然后做处理
SpringMVC处理流程：
  因为在web.xml中配置了DispatcherServlet，还有/，对于它拦截到的请求
  无论是doGet，还是doPost，或者是doPut，doDelte这些都是调用processRequest处理
  processRequest前后是一些对属性的封装之类，发布监听事件之类，核心在doService中
  doService的前面是一些属性的设置，比如几个重要的resolver，核心是doDispatch
  几个核心的HandlerExecutionChain（核心，包括钩子和业务方法），HandlerMapping（负责url映射），HandlerAdater主要是反射执行（最终是handleRequestInternal-》invoka）
  对于modelandview，如果只有数据，view为空，如果有view找到viewResolver，这个会找到并渲染
      protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
        HttpServletRequest processedRequest = request;
        HandlerExecutionChain mappedHandler = null;
        boolean multipartRequestParsed = false;
        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

        try {
            try {
                ModelAndView mv = null;
                Object dispatchException = null;

                try {
                    processedRequest = this.checkMultipart(request);
                    multipartRequestParsed = processedRequest != request;
                    //根据request的url获取对应的HandlerExecutionChain（Interchain），和方法
                    mappedHandler = this.getHandler(processedRequest);
                    if (mappedHandler == null) {
                        this.noHandlerFound(processedRequest, response);
                        return;
                    }
                    //然后得到HandlerAdapter
                    HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler());
                    String method = request.getMethod();
                    boolean isGet = "GET".equals(method);
                    if (isGet || "HEAD".equals(method)) {
                        long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                        if ((new ServletWebRequest(request, response)).checkNotModified(lastModified) && isGet) {
                            return;
                        }
                    }
                    //拦截器前面的逻辑
                    if (!mappedHandler.applyPreHandle(processedRequest, response)) {
                        return;
                    }
                    //handlerAdapter 用反射执行
                    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
                    if (asyncManager.isConcurrentHandlingStarted()) {
                        return;
                    }

                    this.applyDefaultViewName(processedRequest, mv);
                    //拦截器
                    mappedHandler.applyPostHandle(processedRequest, response, mv);
                } catch (Exception var20) {
                    dispatchException = var20;
                } catch (Throwable var21) {
                    dispatchException = new NestedServletException("Handler dispatch failed", var21);
                }

                this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);
            } catch (Exception var22) {
                this.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);
            } catch (Throwable var23) {
                this.triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException("Handler processing failed", var23));
            }

        } finally {
            if (asyncManager.isConcurrentHandlingStarted()) {
                if (mappedHandler != null) {
                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
                }
            } else if (multipartRequestParsed) {
                this.cleanupMultipart(processedRequest);
            }

        }
    }

71.如何避免sql注入
  使用PreparedStatement预编译
72.throw和throws区别
  throws在方法上抛出，往上传，不处理
  throw代码里抛出
73.final,finally,finalize 区别
  final 类，方法，变量
  finally try catch finally必须执行
  finalize 要被gc的时候会执行的方法
74.try,catch,finally中，如果catch中return了，finall是否会执行
  public static int a(){
        int a=10;
        try{
            a=20;
            a=10/0;
            return a;
        }catch (Exception e){
            return a;
        }finally {
            a=30;
            
        }
    }
    返回试一下上面这个方法，联想一下函数执行过程操作数栈，出口地址相关，其实就是在return的时候把操作数的值赋给某个地址，然后继续向下执行
 78.常见的异常类有哪些
    throwable->error
    throwable->exception
    java中只有throwable类型才可以被throw和catch
    exception通常是可以预料到的，没有error严重，catch到就可以继续执行，又分为检查异常和非检查异常（RuntimeException）,检查异常必须在写代码的时候trycatch，
    比如ioexception，非检查异常可以不catch
    error通常是问题比较严重，jvm级别的，outofmemory这些，一般出现就差不多gg了
 79.http响应码301和302区别，以及重定向和forward的区别，浏览器是怎么处理的
    301永久重定向 浏览器缓冲新地址，以后直接请求新地址
    302临时重定向q 浏览器每次先收到302，再请求新地址，response.sendRedirect();
 80.forward和redirect的区别
    地址栏没有变化
    带着同样的参数就过去了，redirect传参比较麻烦
 81.简述TCP和UDP的区别：
    物理层，数据链路层，网络层，传输层，会话层，表示层，应用层
    tcp和udp都是传输层协议
    tcp提供可靠的面向连接的服务，udp是无连接的
    tcp传输的数据无差错，不丢失，按序到达，udp尽最大努力交付
    tcp通过校验和，确认机制，序号标识，滑动窗接口保证可靠性
    udp实时性好，工作效率高，tcp需要建立连接，一对一，upd可以一对多
    tcp要占系统资源，比如缓冲
 82. tcp三次握手，两次不行吗，为什么
    说法一：如果只有两次握手，AB建立连接，如果之前因为网络问题滞留的请求建立连接的报文又发到B，就会又建立一次连接，如果三次的话，已经有了连接，不会重复建立
    说法二：其实根源是为了双方同步序列号，分别发送自己的序号，并得到确认
83. tcp粘包是怎么产生的
    假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到字节数是不确定的，可能存在以下几种情况：
      服务端分两次读取到了两个独立的数据包，分别是D1和D2,没有粘包和拆包
      服务端一次接收到了两个数据包，D1和D2粘合在一起，称之为TCP粘包
      服务端分两次读取到了数据包，第一次读取了完整的D1和D2包的部分内容，第二次读取到了D2包的剩余内容，这称之为tcp拆包
      ，，，
84 OSI的七层模型都有哪些
    应用层：网络服务与最终用户的一个接口
    表示层：数据的表示，安全，压缩
    会话层：建立，管理，终止会话
    传输层：定义传输数据的协议端口号，以及流控和差错校验
    网络层：进行逻辑地址寻址，实现不同网络之间的路径选择
    数据链路层：建立逻辑连接，进行硬件地址寻址，差错校验等功能
    物理层：建立，维护，断开物理连接
85. get和post请求有哪些区别
    都是请求方法，还有option，put，trace这些
    get上传参数只能通过url，有长度和编码限制，且会直接显示在地址栏上
    post通过请求正文传参，不会显示在地址栏，可以有多种形式，text，xml，json这些，编码多种
86.如何实现跨域
  什么是跨域：前端调用的后端接口不属于同一个域（域名或端口不同），就会产生跨域问题，也就是说你的应用访问了该应用域名或端口之外的域名或端口
 
88.说一下你熟悉的设计模式
   创建型模式：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式
   结构性模式：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式
   行为型模式：策略模式，模板方法模式，观察者模式，迭代器模式，责任链模式，命令模式，备忘录模式，状态模式，访问者模式，中介者模式，解释器模式
   设计模式遵循的原则：对扩展开发，对修改关闭
   里氏替换：只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，衍生类也能在基类的基础上增加新的行为
   依赖倒置原则：
   接口隔离：使用多个隔离的接口来降低耦合度
   迪米特法则：一个实体应当尽量少与其他实体之间发生相互作用
   合成复用：
    从 
   工厂模式：
   简单工厂：
   interface food{}
   class A implements food{}
   class B implements food{}
   class C implements food{}
   class Factory{
      public static food getInstance(String name){
          food x=null;
          if(name.equals("A")){
              x=new A();
          }else if(name.equals("B")){
              x=new B();
          }else{
              x=new C();
          }
          return x;
      }
   }
   抽象工厂：
   interface food{}
   interface Factory{
      food getInstance();
   }
   class A implements food{}
   class B implements food{}
   class FactoryA implements Factory{
      food getInstance(){
          return new A();
      }
   }
   class FactoryB implements Factory{
      food getInstance(){
          return newB();
      }
   }
   public class AbstractFactory{
      public static void main(String []args){
          food x=new FactoryA().getInstance();
      }
   }
   单例模式
   public class SingleTon{
      public static SingleTon instance=null;
      public static SingleTon getInstance(){
          if(instance==null){
              synchronized(this){
                  instance=new SingleTon();
              }
          }else
          return instance;
      }
   }
   public class SingleTon{
      public static class Inner{
        puglic static SingleTon instance=new SingleTon();
      }
      public static SingleTon getInstance(){
          return Inner.instance;
      }
   }
   建造者模式：
   原型模式（实现clone方法）
   适配器模式，为类增加新的功能：类适配，对象适配，接口适配
   装饰模式
   代理模式
   外观模式
   桥接模式
   组合模式
   享元模式（使用共享对象的方法，用来尽可能减少内存使用量。通常使用工厂类辅助）
   abstract class flywei{}
   public class Flyweight extends flywei{
    Object obj;
    public Flyweight(Object obj){
    this.obj=obj;
    }
   }
   class FlyweightFactory{
    private HashMap<Object,Flyweight> data;
    public FlyweightFactory(){
      data=new HashMap<>();
    }
    public Flyweight getFlyweight(Object object){
      if(data.containsKey(object)){
        return data.get(object);
      }else{
        Flyweight flyweight=new Flyweight(object);
        data.put(object,flyweight);
        return flyweight;
      }
    }
   }
89.简单工厂和抽象工厂有什么区别
90.为什么要使用spring
    个人理解：作为一个容器来说，提供了很多便利，提供了一个框架，可以很方便地进行开发，进行web开发时，只需要开发bean
    1.简介
      目的：解决企业应用开发的复杂性
      功能：使用基本的javaBean替代EJB
      范围：任何java应用
      Spring 是一个轻量级的控制反转和面向切面的容器框架
      轻量级
	无论从大小还是开销来说都是轻量的，使用最小功能比如IOC和aop用到的非常小，非侵入式，没有说继承某个类，大部分都是通过注解
      控制反转
	Spring通过控制反转实现了松耦合。当我们没有使用spring时，使用一个对象需要自己去new
                如果有一些对象属性，还要new这些属性，使用的时候耦合度较高，也比较复杂，使用ioc功能，
	容器在初始化的时候，就会把我们需要的对象放在容器中，并且注入他的各个属性，容器在初始化一个
	对象的时候，会发现它的依赖，然后先注入依赖，再继续初始化对象
      面向切面
	允许动态对某些代码进行功能增强，而且实现了业务和增强功能的分离
      容器
	根据配置文件可以配置bean如何被创建，bean可以创建一个单独的实例或者每次需要时都生成一个新的实例，以及他们是如何关联的
      框架
	集成框架方便
91.解释aop
	aop是相对于oop而言的，面向对象编程是一种纵向的关系，
	可以很容易的通过继承，多态实现模板行为，但是这些是建立再
	实现公共行为的类继承自同一个类，而且都是静态的，而且这些公共行为
	往往和类有一些关系，而oop是为一些不相关的类添加一些和业务无关的行为
	比如日志，权限校验这些，aop技术利用动态代理的技术，可以把这些分散在各处且
	和业务无关的代码封装在切面中插入。其实就是在执行流程中，找到一个切入点，将
	实现了新功能的切面切入。Aop的两个关注点：核心关注点和横切关注点。连接点和切入点
92.解释一下什么是ioc
	其实翻译成依赖注入的话是很好理解的，就是说初始化一个对象的时候，发现它的某些属性
	也就是它依赖这个属性，需要初始化属性，把这个属性注入
	如果翻译成控制反转的话，当没有框架的时候，需要初始化一个对象，它的属性需要使用主动去初始化，注入
	当有了框架之后，如果需要，容器自动注入，用户变成了被动，控制权交给了配置文件
93.Spring有哪些主要模块
	基本核心容器：core，beans，context，spel
	AOP
	web
	data
	测试
94.Spring常用的注入方式有哪些
	a.构造方法注入
		<bean id="userService" class="com.example.service.impl.UserService>
			<constructor-arg name="userDao" ref="userDaoJdbc"></constructor-arg>
		</bean>
	b.setter注入
		<bean id="userService" class="com.example.service.impl.UserService">
			<property name="userDao" ref="userDao"/>
		</bean>
	c.基于注解的注入
		autowire:constructor,byName,byType
			constructor:通过构造方法进行自动注入，spring会匹配与构造方法参数类型一致的bean进行注入
			byName:被注入bean的id名必须与set方法后半截匹配，并且id名称的第一个单词首字母必须小写
			byType:查找所有的set方法，将符合参数类型的bean注入
		四种可以注册的bean：
			Component，Repository，Controller，Service
		自动注入的注解：
			Resource（默认byName，如果没有bytype，如果多个qualifier）
			Autowired（默认byType）
95.spring中的bean是线程安全的吗
	如果是单例的话，就是安全的，容器没有线程安全方面的操作
96.spring支持几种bean的作用域
	Singleton
	prototype
	request
	session
	globalsession
	默认Singleton
97.spring自动装配bean有哪些方式
	xml配置，代码配置
98.spring事务实现方式有哪些
	@Transactional（rollbackFor={RuntimeException,Error.class}）
	rollbackFor:触发回滚的异常，默认是RuntimeException和error
99.spring的事务隔离|数据库的事务隔离
	未提交读
	已提交读
	可重复读
	可串行化
        造成的问题：脏读（读取到未提交的数据），不可重复读（在同一个事务中，前后两次读取到的不一样），幻读（执行完自己的草走发现多出来一条数据）
100.spring mvc的运行流程
	加载的时候把handlerMapping，handlerAdapter加载，handlerMapping是url和地址的封装，收到一个请求，符合路径匹配，交给DispatcherServlet，zhixing
	doDispatch，根据url得到一个handlerExecution（封装了intercetpor和method），然后根据类型得到adapter，执行一个类似preHandler 后面postHandler
	中间invoke，得到ModeAndView，如果view说明直接返回数据，如果view不为空，从viewResolver里面找到对一个视图，渲染数据
101.Spring MVC有哪些组件
	dispatcherServlet
	controller
	handlerMapping
	handlerAdapter
	ModelAndView
	ViewResolver
	Intercetpor
102. @RequestMapping的作用
	使用的时候，表示这个接口的地址以及方法，还要数据类型之类的作用，作为一个注解
	当然是在初始化的时候告诉系统这个注解修饰的方法是接口方法，放在响应的map里
	value method consume（请求数据类型） produces（返回数据类型） params（请求里必须包含某些参数） header（请求头必须包含某些字段）
103 Autowired 的作用是什么
	根据type自动注入，type不止一个时，qualifier根据名称注入
104.什么是spring boot
	其实spring boot真正的实现和普通的ssm项目没有什么不同
	只是帮我们做了以前复杂的配置，现在导包经常会用到一个spring-boot-starter，，，或者第三方包-starter,打开这些包，可以看到
	只是做了一些自动从application.properties的操作，当然，这就导致，如果你导入某些包，必须在application。properties中配置，
	要不然会报错，如果新增配置或者修改的话，需要覆盖，还有就是内嵌了tomcat容器可以直接以jar包形式运行
105. 为什么要用spring boot
	减少版本冲突
	简化配置
	简化部署
106.spring boot的核心配置文件
	application(-dev).properties
107.spring boot的配置文件有哪几种
	properties yml
108.spring boot实现热部署
	spring-boot-devtools
	配置路径


	
	
  























