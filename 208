1.JDK和JRE有什么区别
  JDK,java develop kit java开发工具包，包括运行环境和开发环境（各种工具，javac之类的）
  JRE，java runtime environment，java运行环境，一些基本类库和虚拟机
  JDK>JRE>虚拟机
2.==和equals的区别是什么
  ==如果是基本数据类型，比较值是否一致，如果是对象，比较内存地址是否相同
  equals默认和==一致，只是有的类修改了，比如string，比较指向的内容是否一致
3.两个对象的hashcode相同，equals也一定一致吗
  不一定，hashcode如何计算（https://blog.csdn.net/qq_38182963/article/details/78940047）
  String 的hashCode计算
  public int hashCode(){
    int h=hash;
    if(h == 0 && value.lenght > 0){
      char val[] = value;
      for(int i=0;i<value.length;i++){
        h=31*h+val[i];
      }
      hash=h;
    }
    return h;
   }
  .为什么使用31
    31*i=(i<<5)-i;
4.final 在java中有什么用
  final 类 不可被继承改写
  final 方法 不可被改写
  final 值 不可被修改
5.Math.round(-1.5)
  -1
6.String不属于基本数据类型
7.java中操作字符串的类有哪些
  string 不可变，char[] value被final修饰
  stringbuilder  可变，线程不安全
  stringbuffer    可变，线程安全 方法被synchronized修饰
8 String str="i"和String str=new String("i")有区别吗
  有，"i"是字面量，在方法区，第一个直接指向方法区字面量，第二个指向堆内地址
9.如何将字符串反转
  string 没有reverse方法，stringbuffer和stringbuilder可以
10.String类常用的方法有哪些
   charAt trim equals replace machtches split substring
11.抽象类必须有抽象方法吗
   可以没有，甚至可以有Main方法
12.普通类和抽象类有什么区别
   abstract关键字
   普通类不能有抽象方法
   抽象类不能实例化
13.抽象类能用final修饰吗
  不可以
14.接口和抽象类有什么区别
  关键字
  接口里的变量都是final类型，不能用private，抽象类可以有普通变量
  接口里不能有非抽象方法，抽象类可以有（接口可以使用default方法）
  接口多实现，抽象类单继承
15.java中的io流
  输入流输出流
  字符流（16位）字节流（8位）
16.Bio，Nio，Aio区别（https://zhuanlan.zhihu.com/p/66148226）
  Bio ，Block io，同步阻塞，无论是等待建立连接或是传输数据，都会阻塞，程序不能像下执行
  Nio ，New io ，同步非阻塞，主要组件：选择器，通道，缓冲
  
17.锁升级
   对象放在内存中，分为对象头，实例变量，填充字节
    对象头有mark word，class point（指向它的类元数据的指针）
    实例变量存储的是属性信息，包括父类的属性信息，按照四字节对其
    填充字符，要求8字节的整数倍
    在64位的虚拟机中，mark word https://img-blog.csdn.net/20180322153316377
    
    锁状态                       56bit                           1bit                  4bit              1bit                    2bit
                        25bit                 31bit                                                 是否偏向锁                 锁标志位
    无锁                unused                hashcode           cms_free             对象分代年龄        0                       01
    偏向锁              锁偏向的线程threadID(54bit)  epoch（2bit） cms_free             对象分代年龄        1                       01
    轻量级锁                                      指向栈中锁记录的指针                                                              00
    重量级锁                                      指向重量级锁的指针                                                                10
    GC标记                                          空                                                                            11
    
    Synchronized对应的是重量级锁
      重量级锁对应的锁标志位是10，存储了指向重量级监视器锁的指针，在hospot中，对象的监视器（monitor）锁对象由ObjectMonitor对象实现（C++）
      数据结构：
        ObjectMonitor（）{
          _count      =0;   //用来记录该对象被线程获取锁的次数
          _waiters    =0;  
          _recursions =0;   //锁的重入次数
          _owner      =null;//指向持有ObjectMonitor对象的线程
          _WaitSet    =null;//处于wait状态的线程，会被加入到_waitSet
          _waitSetLock=0;   
          _EntryList  =null;//处于等待锁block状态的线程，会被加入该列表
        }
      偏向锁：
        大多数时候是不存在竞争的情况下，常常是一个线程多次获得同一个锁，因此如果每次都要竞争会增大很多没有必要付出的代价，为了降低获取锁的代价，才引入偏向锁
        当线程1访问代码块并获取锁对象时，会在java对象头和栈帧中记录偏向的锁的threadID,因为偏向锁不会主动释放锁，因此以后线程1再次获取锁的时候，需要比较当前线程
        的threadID和java对象头中ttreadID是否一致，如果一致，还是线程1获取锁对象，无需使用CAS加锁，如果不一致，比如线程2请求，那么查看java对象头中记录的线程1
        是否存活，若没有存货，那么锁对象被重置为无锁状态，其他线程2可以将其置成偏向锁，如果存活，立刻查找这个线程的栈帧，如果还需要继续使用这个线程，那么暂停1，撤销偏向锁，升级为轻量级锁，如果线程1
        不需要使用该锁，将锁对象设为无锁，重新偏向新的线程
     轻量级锁：
        考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。自旋等待
        线程1获取轻量级锁时先把锁对象的对象头Markword复制一份到自己的栈帧中用于存储所记录空间，然后使用cas把对象头中的内容替换为线程1存储的锁记录的地址
        如果在线程1复制对象头的同时（在线程cas之前），线程2也准备获取锁，复制了对象头的线程2的锁记录空间中，但是在线程2CAS的时候，发现线程1已经把对象头换了，线程2的
        cas失败，那么线程2就尝试使用自旋锁来等待1释放锁
        自选一定次数之后升级为重量级锁，把除了拥有锁的线程都阻塞，防止cpu空转
     注意：为了避免无用的自旋，轻量级锁一旦膨胀为重量级锁就不会再降级为轻量级锁了；偏向锁升级为轻量级锁也不能再降级为偏向锁。但是偏向锁可以被重置为无锁
     所以适用范围显而易见：
        偏向锁：基本是单线程
        轻量级锁：多线程，切换频繁
        重量级锁：多线程，占有时间长
     
49 什么是死锁
  多个线程竞争资源，陷入循环等待，如果没有一个线程放弃请求，永远不能向前进行
50怎么防止死锁
  死锁的四个条件：互斥，非抢占，占有并等待，循环等待，破坏条件：
  一次申请所有的资源，申请不到即放弃，给资源编号
51.ThreadLocal https://blog.csdn.net/X8i0Bev/article/details/101086604
  ThreadLocal是一个本地线程副本变量工具类，各个线程都拥有一份线程私有的数据，线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用。
  实现：每个thread内部有一个map，key是共享变量的名字，value是真正的变量副本
  threadLocat的set
  public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    }
    public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }
    应用场景：数据库连接，session
   52.synchronized实现原理
    普通方法，静态方法，同步代码块
    重新中内存中取值，并锁定不能被修改，通过修改对象头，每个对象头有个monitor，monitor锁指针指向该该线程
   53.synchronized和volatile的区别
    volatile虽然保证了可见性，但是没有锁机制，同时能有多个线程访问到原始数据，然后一起修改更新回主存，因为并发性高，所以性能高
    volatile只能修饰变量
    volatie不能被优化
  54.synchronized和lock有甚区别
    实现交替打印（1.synchronized和wait notify 2.lock condition 3.lockpart）
    看一下Lock实现ReentrantLock
   final void lock() {
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
   }
        
    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
    tryAcquire调用以下
    final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0) // overflow
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
   acquireQueued（） 调用以下
   final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
    addWaiter如以下：
    private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        enq(node);
        return node;
    }
    
    二者区别：
      用法
      一个队列和两个队列
      一个是对对象头，监视器的操作，一个是对线程的操作
54 synchronized和lock的区别
    synchronized是个关键字，jvm层面，lock是个java类
    synchronized无法判断是否获取锁的状态，lock可以判断
    synchronized会自动释放锁
    synchronized可重入，不可中断，非公平
55 synchronized和ReetrantLock区别
  对获取锁的时间进行设置，避免一直阻塞
  synchronized通过对象头实现，reentrantlock通过unsafe.park实现，unsafe实现
    
55.说一下atomic的原理
  我举得先看下unsafe类：
    unsafe功能：
      普通读写：读写一个object对象的field，直接从内存的一个地址读写
      volatile读写：volatile读写一个object的field，volatile可以保证可见性和有序性
      有序写：有序写一个object的field，保证有序性，不保证可见性
      内存操作：申请内存，重新申请内存，释放内存，内存复制
      cas相关：提供int，long，object的cas操作
      偏移量相关：获取对象属性和静态属性的偏移量
      线程调度：挂起线程，唤醒线程
      类加载：定义类，创建对象，定义匿名内粗堡垒，判断是否加载类
      内存屏障：读屏障，写屏障，读写屏障
      
      LockSupport基于unsafe实现
      Atomic 值volatile ，所有的操作都通过unsafe
56.什么是反射
  反射是可以在运行时对类进行操作，可以在运行时拿到类的信息，拿到类的方法，字段，开可以newInstance生
