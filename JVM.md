# learnNote
工具
jps 类似于ps，查看java进程
  参数：
    -q：只输出进程ID
    -m:输出传入main方法的参数
    -l:输出完全的报名，应用主类名，jar包的完全路径
    -v:输出jvm的参数
    -V：输出通过flag文件传递到jvm中的参数
    jps [args] [host]查看远程服务
 
jstat 根据pid查看jvm的gc情况
   jstat [args] [pid] [间隔时间/ms] [查询次数]
   参数：
    -class:类加载统计
      Loaded：加载的class数量
      Bytes：所占用空间大小
      unloaded：未加载数量
      bytes：未加载占用空间
      time：时间
     -compiler：编译统计
      compiled:编译数量
      failed：失败数量
      invalid：不可用数量
      time：时间
      failedtype：失败类型
      failedMethod：失败的方法
     -gc：垃圾回收统计
      SOC:第一个存活区大小
      S1C:第二个存活区大小
      S0U:第一个幸存区的使用大小
      S1U:第二个幸存区的使用大小
      EC:伊甸园区的大小
      EU:伊甸园区的使用大小
      OC:老年代大小
      OU:老年代使用大小
      MC:方法区大小
      MU:方法区使用大小
      CCSC:压缩类空间大小
      CCSU:压缩类空间使用大小
      YGC:年轻代垃圾回收
      YGCT:年轻代垃圾回收消耗时间
      FGC:老年代垃圾回收次数
      FGCT:老年代垃圾回收消耗时间
      GCT:垃圾回收消耗总时间
     -gccapacity：堆内存统计
     -gcnew:新生代垃圾回收统计
     -gcnewcapacity:新生代内存统计
     -gcold:老年代垃圾回收统计
     -gcoldcapacity:老年代内存统计
     -gcmetacapacity:元数据空间统计
     -gcutil:总结垃圾回收统计
     -printcompilation：jvm编译方法统计
jmap：jmap查看当前java堆和元数据区的详细信息 jmap [options] [pid]
  -heap:
  jmap -dump:format=b,file=文件名 PID 生成dump文件
jhat：分析dump文件
  jhat  -J-Xmx512M a.log，开启一个7000端口的本地服务
mat：推荐进行dump分析的工具
jstack:查看运行时线程栈信息 jstack [args] pid
jconsole:图形界面化查看cpu，内存，类加载，线程运行情况
jvisualvm：可以进行堆dump和线程dump
  
  
  
JDK 1.1 JAR,JDBC,JavaBeans,RMI
JDK 1.2 Playground  j2se j2ee j2me  HotSpot
JDK 1.3 kESTREL
JDK 1.4 mERLIN
JDK 1.5 Tiger
JDK 1.6 Mustang
JDK 7
JDK 8 lambda ,彻底移除HotSpot 永久代
oracle 把 java ee送给eclipse基金会， 改名jakarta ee

第二章
运行时数据区：方法去，虚拟机栈，本地方法栈，堆，程序计数器
  程序计数器：字节码行号指示器，线程私有
  java虚拟机栈：描述方法执行的线程内存模型
    栈帧：局部变量表，操作数栈，动态连接，方法出口等信息
      局部变量表：基本数据类型，对象引用（指针或者句柄），returnAddress（指向了一条字节码指令的地址），在这个内存区域可能报StackOverflowError，OutOfMerroy
   本地方法栈：会报StackOverflowError和OutOfMemeory
   java堆：
   方法区：存储已被虚拟机加载的类型信息，常量，静态变量，jdk8之前称为永久代，jdk8之后改用在本地内存中实现的元空间来代替，永久代有大小限制
    运行时常量池：是方法区的一部分。class文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池表，用于存放编译器生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
              String类型的intern（）可以放入常量池中
 创建一个对象的过程：
  当虚拟机遇到new指令，检查这个指令的参数能否在在常量池中定位到一个类的符号引用，并且检查这个类的符号引用是否被加载，解析和初始化，如果没有，必须先执行类加载
  为对应分配空间（指针碰撞或者空闲列表，决定于gc是否有整理能力），分配空间有线程安全问题，并且初始化零值
  对对象进行设置，类的元数据，对象哈希码，对象的gc粉黛年龄，，偏向锁，等
  构造函数
对象的内存布局：
  对象头：Markword运行时数据（哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程id，偏向时间戳）；类型指针（指向它的类型元数据的指针），如果是数组，还得有长度字段
  实例数据
  对齐填充 8字节的整数倍
引用类型：
  句柄
  指针（HotSpot）
  
  
实战：OutOfMemoryError异常
  发现异常
  加参数，报异常时dump出来
  用工具jmap ，或者eclipse memory analyzer分析，确认内存中导致oom的对象是否有必要，也就是区分到底是内存泄漏还是内存溢出
  如果是内存泄漏，看看是哪个引用导致没有被回收，如果是内存溢出，可能就有必要去扩大堆参数
实战：虚拟机栈和本地方法栈溢出
  如果栈深度大于虚拟机允许的最大深度，将抛出StackOverflowError异常
  如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常
  根据错误信息查找
  
方法区和运行时常量池溢出
  循环intern，在jdk6及以前会报异常，之后放在堆中，及jdk6之后，运行时常量池放在java队中
  在jdk6中，intern（）方法会把首次遇到的字符串实例复制到永久代的字符串常量池中存储，返回的也是永久代里面这个字符串实例的引用
  jdk7中，。intern（）只需要记录堆中首次出现该字符串的引用在常量池中
  jdk8之后元空间默认大小本机内存，也可以设置，达到该值就会进行类型卸载，同时进行调整
  
先注意一下：
  Minor Gc Major（old）GC FULL GC 区别
  
引用计数法
可达性分析算法
  可作为GC ROOTS的对象：
    栈帧中局部变量表中引用的对象
    方法区中静态属性引用的对象
    在方法区中常量引用的对象
    本地方法栈中引用的对象
引用：强引用，软引用，弱引用，虚引用
  强引用：就算OOM,也不会回收
  软引用：在OOM之前，回收
  弱引用：遇到即回收
  
  
一个对象被回收要经历两个阶段:
  没有被引用的时候，第一次被标记，判断是否要执行finalize（是否重写且没有执行），如果该方法没有被重写或者已经执行，直接回收，否则，加入另一个队列，等待调用该方法
回收方法区：
  废弃的常量和不再使用的类型
  
跨代引用假说：在新生代建立一个全局的数据结构，存储老年代哪些块存在跨代引用，minor GC 的时候顺便扫遍这部分老年块
Minor GC/Young GC
Major GC/Old GC
Full GC
通常能单独发生收集行为的只是新生代，实际上除了CMS收集器，其他都不存在只针对老年代的收集

标记清除算法
  ：首先标记所有需要回收的对象，标记完成后，同一回收掉所有未被标记的对象
  缺点：内存碎片，如果分配大空间可能会不够然后导致又一次回收
标记复制算法：
  解决了内存碎片的缺点
  缺点:空间浪费，新生代经常采用
eden ，survior0，survior1
  分配担保：当survior不足以一次minorgc时，直接放入老年代
标记整理：
  移动存活对象，stop the world
  
垃圾收集器：
  Serial，在JDK1.3.1之前是HotSpot虚拟机新生代唯一的选择，新生代复制，老年代整理即使是现在也是客户端模式下默认的新生代收集器 
  ParNew：多线程版Serial ，JDK7之前的首选新生代收集器
  CMS:JDK5出现的，老年代使用，首次意义上并发，所以在JDK5中使用CMS收集老年代的时候，新生代只能选择ParNew或者Serial中的一个
  G1:从JDK9开始，ParNew加CMS不再是推荐的唯一服务器模式，官方希望能被G1完全取代
  Parallel Scavenge：新生代，标记复制，并行，关注吞吐量，两个参数最大回收停顿时间，吞吐量，自适应
  Serial Old：Serial老年代版本，单线程，标记整理，客户端模式下的hotspot使用
  CMS:获取最短停顿时间，初始标记，并发标记，重新标记，并发清除，其中，初始标记，重新标记需要stop the world
    缺点：占用用户线程资源，浮动垃圾
  G1:JDK9发布的时候，宣告取代Parallel Scavenge+Parallel Old组合，初始标记，并发标记，最终标记，筛选清除，其中只有并发标记不暂停用户线程
  
 Class类文件结构：
  魔数（CAFFEBABE） 版本，不使用扩展名，安全
  常量池:字面量和符号引用
    字面量：文本字符串，被声明为final的常量值
    符号引用: 被模块导出或者开放的包
              类和接口的全限定名
              字段的名称和描述符
              方法的名称和描述符
              方法句柄和方法类型
              动态调用点和动态常量
    java代码在编译的时候不会像c那样动态连接，而是在虚拟机加载class文件的时候进行动态连接，也就是说，在class文件中不会保存各个方法，字段最终在内存中的布局信息，这些符号引用不经过虚拟机在运行期间转换的话无法得到真正的内存入口地址在类创建或运行时解析，翻译到具体的内存地址中，c++可以直接调用dll，java调用其他jar包必须加载到jvm中 
   而且内存地址不定，所以需要在运行的时候根据符号名寻找
  访问标志：是类还是接口，是否定义为public类型，具体定义为abstract，如果是类，是否final
  类索引，父类索引，接口索引集合
  字段标集合：全限定名，简单名
	描述符：描述字段的数据类型，方法的参数列表返回值
  方法表集合：访问标志，名称索引，描述符索引，属性表集合，如果父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息
	但同样地（多态实现，如果这个类的方法表里没有，就去父类找）
  属性表集合：
	

字节码指令简介
	java虚拟机的指令由一个字节长度的，代表着某种特定操作含义的数字以及跟随其后的零至多个操作数构成。
	由jvm采用面向操作数栈而不是面向寄存器的结构，所以大多数指令都不包含操作数，只有一个操作码，指令草书都存放在操作数栈中，一个不过256条

	大部分指令都没有支持整数类型byte，char和short，甚至没有任何指令支持boolean，会扩展为int，
  
  
 类加载：
	加载，验证，准备，解析，初始化，使用，下载
	时机：
		遇到new，getstatic，putstatic，invokestatic
		反射调用
		初始化类的时候，发现父类还没有初始化
		虚拟机启动时，用户需要制定执行的主类
	加载：
		获取二进制字节流
		将字节流所代表的静态存储结构转化为方法去的运行时数据结构
		在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口
	验证：
		放置恶意的字节流，可能不符合class文件格式的约束
			文件格式验证：魔数，主次版本号，常量池规范
			元数据验证：是否有父类，是否继承了不被允许继承的类，实现了父类或接口的方法，字段，方法，与父类矛盾
			字节码验证：程序语义是否合法，符合逻辑
			符号引用验证：是否能找到对应引用
	准备：
		初始化static变量 static 变量准备之后是0，执行init之后才是对应值
	解析：符号引用替换为直接引用
	初始化：执行clinit（类变量的赋值动作和静态语句块），父类的clinit先执行

方法调用：静态连接和动态连接
	加载时就能确定执行的地址
	运行时才能确定，也是多态实现的原理，符号引用解析为直接引用

分派：静态分派和动态分派
	静态分派实现重载，Human h=new Man();Human是静态类型，Man是实际类型，重载时是通过参数的静态类型而不是实际类型作为判定依据的，静态类型在编译器可知，所以在编译期间，javac编译器就根据参数的静态类型决定了会使用哪个重载版本。
	不唯一时，选择更合适

	动态分派：重写
	调用过程：
	找到操作数栈顶的第一个元素指向的对象的实际类型，记作c
	如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过返回直接引用
	否则，按照继承关系从下往上对父类机型第二部的搜索和验证

	字段不参与多态，子类覆盖父类
  
  
  
  
  
  
